# LC3 Code Analysis -- Assembler

### Object Two
1. Learn how to write assembler in general
2. Learn the source code of LC-3's assembler
3. How to write an assembler from scratch?

### How to write an assembler in general

#### What are the essential parts of an assembler?

1. Symbol Table
2. Directives

And there are some assembler with "high-level" features such as "macro", and something called "Meta-assembler"

### How to understand assembling from the perspective of its general process?

First, we need to know the line is a directive or a instruction.

If it is an instruction, we need to do some basic lex analysis, to get the operands. With operands, we still needs some further transformation, to make the code a "Relocatable" one or "executable object file". We need a symbol table to achieve this.

If it is a directive, we needs to generate code according to the rules, the difference from the former one is that there is no corresponding instruction for a directive. The pre-loaded data are always maintained by directives.

There are several states in assembling process, namely, line counter is the most important one. The "offset" is actuall decided in the context of line counter, while the "label" is decided in the context of symbol table.

Some details from ISA will effect the legitimacy of the operands even if they can be extracted out correctly, such as the range of an immediate value, the numbering of a register etc.

The errors in dealing with directives is rather simple, as long as their features are well-defined.

Question: One-Pass v.s. Two-Pass

### How to analyze the C code of LC3 Assembler
#### Framework
The LC-3 Assembler is a two-pass assembler, with very succinct instructions set, and a few directives. The main work of the assembler is done with the help of flex (GNU's lex), which is a scannar generator.

So, the assembler is described in the environment, the main function and the functions to call when certain pattern is matched. They are written in the file `lc3.f`. What's more, there is also a symbol table interface defined.

#### Assembler
##### Global Environment

	static int pass, line_num, num_errors, saw_orig, code_loc, saw_end;
	static inst_t inst;

##### Pattern Matching

	REGISTER [rR][0-7]
	HEX      [xX][-]?[0-9a-fA-F]+
	DECIMAL  [#]?[-]?[0-9]+
	IMMED    {HEX}|{DECIMAL}
	LABEL    [A-Za-z][A-Za-z_0-9]*

	/* operand formats */
	O_RRR  {SPACE}+{REGISTER}{OP_SEP}{REGISTER}{OP_SEP}{REGISTER}{ENDLINE}
	O_RRI  {SPACE}+{REGISTER}{OP_SEP}{REGISTER}{OP_SEP}{IMMED}{ENDLINE}
	O_RR   {SPACE}+{REGISTER}{OP_SEP}{REGISTER}{ENDLINE}
	O_RI   {SPACE}+{REGISTER}{OP_SEP}{IMMED}{ENDLINE}

	ADD       {inst.op = OP_ADD;   BEGIN (ls_operands);}
	AND       {inst.op = OP_AND;   BEGIN (ls_operands);}
	BR{CCODE} {inst.op = OP_BR;    parse_ccode (yytext + 2); BEGIN (ls_operands);}
	JMP       {inst.op = OP_JMP;   BEGIN (ls_operands);}
	JSRR      {inst.op = OP_JSRR;  BEGIN (ls_operands);}

	<ls_operands>{O_RRR} {generate_instruction (O_RRR, yytext); BEGIN (0);}
	<ls_operands>{O_RRI} {generate_instruction (O_RRI, yytext); BEGIN (0);}
	<ls_operands>{O_RR}  {generate_instruction (O_RR, yytext);  BEGIN (0);}


	puts ("STARTING PASS 1");
	pass = 1;
	line_num = 0;
	num_errors = 0;
	saw_orig = 0;
	code_loc = 0x3000; // Default
	saw_end = 0;
	new_inst_line ();
	yylex (); // Analyze


	static int
	read_val (const char* s, int* vptr, int bits)
	{
	    char* trash;
	    long v;

	    if (*s == 'x' || *s == 'X')
		v = strtol (s + 1, &trash, 16);
	    else {
		if (*s == '#')
		    s++;
		v = strtol (s, &trash, 10);
	    }
	    if (0x10000 > v && 0x8000 <= v)
	        v |= -65536L;   /* handles 64-bit longs properly */
	    if (v < -(1L << (bits - 1)) || v >= (1L << bits)) {
		fprintf (stderr, "%3d: constant outside of allowed range\n", line_num);
		num_errors++;
		return -1;
	    }
	    if ((v & (1UL << (bits - 1))) != 0)
		v |= ~((1UL << bits) - 1);
	    *vptr = v;
	    return 0;
	}

	generate_instruction (operands_t operands, const char* opstr){
		// ....
	    switch (inst.op) {
		/* Generate real instruction opcodes. */
		case OP_ADD:
		    if (operands == O_RRI) {
		    	/* Check or read immediate range (error in first pass
			   prevents execution of second, so never fails). */
		        (void)read_val (o3, &val, 5);
			write_value (0x1020 | (r1 << 9) | (r2 << 6) | (val & 0x1F));
		    } else
			write_value (0x1000 | (r1 << 9) | (r2 << 6) | r3);
		    break;
		    // ...
		// ...
		}
	}

##### Lexer Code

	static void new_inst_line ();
	static void bad_operands ();
	static void unterminated_string ();
	static void bad_line ();
	static void line_ignored ();
	static void parse_ccode (const char*);
	static void generate_instruction (operands_t, const char*);
	static void found_label (const char* lname);